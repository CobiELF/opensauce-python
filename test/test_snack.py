from __future__ import division

import math
import unittest
import numpy as np

from sys import platform

# Import user-defined global configuration variables
from tools.userconf import user_default_snack_method

from opensauce.snack import snack_pitch, valid_snack_methods

from opensauce.soundfile import SoundFile

from test.support import TestCase, wav_fns, get_sample_data, get_raw_data


class TestSnack(TestCase):

    longMessage = True

    # Figure out appropriate method to use, for calling Snack
    if user_default_snack_method is not None:
        if user_default_snack_method in valid_snack_methods:
            if user_default_snack_method == 'exe' and (platform != 'win32' and platform != 'cygwin'):
                raise ValueError("Cannot use 'exe' as Snack calling method, when using non-Windows machine")
            default_snack_method = user_default_snack_method
        else:
            raise ValueError("Invalid Snack calling method. Choices are 'exe', 'python', and 'tcl'")
    elif platform == "win32" or platform == "cygwin":
        default_snack_method = 'exe'
    elif platform.startswith("linux"):
        default_snack_method = 'tcl'
    elif platform == "darwin":
        default_snack_method = 'tcl'
    else:
        default_snack_method = 'tcl'

    def test_against_voicesauce_data(self):
        # Test against Snack data generated by VoiceSauce
        # The data was generated on VoiceSauce v1.31 on Windows 7
        for fn in wav_fns:
            f_len = 0.001
            w_len = 0.025
            F0, V = snack_pitch(fn, self.default_snack_method, frame_length=f_len, window_length=w_len, max_pitch=500, min_pitch=40)

            # The first samples in all of our test data yield 0.
            self.assertTrue(np.allclose(F0[:10], np.zeros(10)))

            # Need ns (number of samples) and sampling rate (Fs) from wav file
            # to compute data length
            sound_file = SoundFile(fn)
            data_len = np.int_(np.floor(sound_file.ns / sound_file.fs / f_len));

            # Following VoiceSauce, pad F0 and V with NaN
            pad_head_F0 = np.full(np.int_(np.floor(w_len / f_len / 2)), np.nan)
            pad_tail_F0 = np.full(data_len - (len(F0) + len(pad_head_F0)), np.nan)
            os_F0 = np.hstack((pad_head_F0, F0, pad_tail_F0))

            pad_head_V = np.full(np.int_(np.floor(w_len / f_len / 2)), np.nan)
            pad_tail_V = np.full(data_len - (len(V) + len(pad_head_V)), np.nan)
            os_V = np.hstack((pad_head_V, V, pad_tail_V))

            # NB: It doesn't matter which output file we use, the sF0 column is
            # the same in all of them.
            vs_F0 = get_raw_data(fn, 'sF0', 'strF0', 'FMTs', 'estimated')
            vs_V = get_raw_data(fn, 'sV', 'strF0', 'FMTs', 'estimated')

            # Either corresponding entries for OpenSauce and VoiceSauce data
            # have to both be nan, or they need to be "close" enough in floating precision
            self.assertTrue((np.isclose(os_V, vs_V) | (np.isnan(os_V) & np.isnan(vs_V))).all())
            self.assertTrue((np.isclose(os_F0, vs_F0, rtol=3e-05) | (np.isnan(os_F0) & np.isnan(vs_F0))).all())

    def test_raw(self):
        # Test against previously generated data to make sure nothing has
        # broken and that there are no cross platform or snack version issues.
        # Data was generated by snack 2.2.10 on Manjaro Linux.
        for fn in wav_fns:
            F0, V = snack_pitch(fn, self.default_snack_method, frame_length=0.001, window_length=0.025, max_pitch=500, min_pitch=40)

            # Check V data
            # Voice is 0 or 1, so (hopefully) no FP rounding issues.
            sample_data = get_sample_data(fn, 'V', 'sf0', '1ms')
            # Check that all voice data is either 0 or 1
            self.assertTrue(np.all((V == 1) | (V == 0)))
            self.assertTrue(np.all((sample_data == 1) | (sample_data == 0)))
            # Check number of entries is consistent
            self.assertEqual(len(V), len(sample_data))
            # Check actual data values are "close enough",
            # within floating precision
            self.assertTrue(np.allclose(V, sample_data))

            # Check F0 data
            sample_data = get_sample_data(fn, 'sF0', 'sf0', '1ms')
            # Check number of entries is consistent
            self.assertEqual(len(F0), len(sample_data))
            # Check that F0 and sample_data are "close enough" for
            # floating precision
            if not np.allclose(F0, sample_data):
                # If first check fails, try lowering relative tolerance and
                # redoing the check
                idx = np.where(np.isclose(F0, sample_data) == False)[0]
                print('\nChecking F0 data using rtol=1e-05, atol=1e-08 in {}:'.format(fn))
                print('Out of {} array entries in F0 snack data, discrepancies in these indices'.format(len(F0)))
                print(idx)
                print('Reducing relative tolerance to rtol=3e-05 and redoing check:')
                self.assertTrue(np.allclose(F0, sample_data, rtol=3e-05))
                print('OK')
            else:
                self.assertTrue(np.allclose(F0, sample_data))
